#############################################################################################################
#													#####
##				Ahlem HAJJEM, François BELLAVANCE, and Denis LAROCQUE		 	 ####
###				Department of Management Sciences HEC Montréal			  	  ###
####				HEC Montréal, 3000, chemin de la Côte-Sainte-Catherine,	   	 	   ##
#####				Montréal, QC, Canada H3T 2A7						    #
#############################################################################################################


####################################	BEGIN THE SCRIPT		#####################################
setwd("/home/...")


sink("Routput.doc")

library(rpart)
library(randomForest)
library(Matrix)
library(lattice)
library(lme4)
library(nlme)
library(MASS)
library(zoo)

set.seed(321)





	########################################################################################################################
	###############################                   ### MERF function ###  	         ##############################
	##################		fits a mixed effects random forest of regression trees model		###############
	########################################################################################################################

	MERF  <- function(

			xnam

			,MERF.lDB = lDB	
			,MERF.tDB = tDB	

			,ni
			,Zi,Yi	

			,ntree
			,mtry
			,nodesize

			,niter
			,verbose 
			,smallest.Jump.allowed 

			,sigmasqzero = NULL
			,Dzero = NULL
			,bizero = NULL

			,w 	#smoothing window
			,sim = 0
		)

	{

	# Specifying values of parameters to be used in this function
		n <- length(ni)
		N <- sum(ni)
		q <- dim(Zi[[1]])[2] # q=1 in random intercept case
		p <- dim(Xi[[1]])[2] # p=1 in random intercept case

	#parameters initial values, sigmasqzero, Dzero, and bizero
		if( is.null(sigmasqzero) ) sigmasqzero <- 1

		if( is.null(Dzero) ){
			if(q==1)Dzero <- diag(x=0.01,nrow=1,ncol=1)
			if(q==2)Dzero <- matrix(c(0.01 ,0,0 ,0.01),nrow=2)
		}

	 	if( is.null(bizero) ){
			bizero <- list(); length(bizero)<- n
			if(q==1){for(i in 1:n) bizero[[i]] <- matrix(0,nrow=1,ncol=1)}
			if(q==2){for(i in 1:n) bizero[[i]] <- matrix(0,nrow=2,ncol=1)}
		}

	#########################################################
	####	STEP 0: Memory Allocation and initialization	#         
	#########################################################

	#iter number
		r <- 1
		if (verbose) 	
			message("MERF iter ", r)

	#transformed outcome, star.Yi[[r]][[i]], initialized with the original values
		star.Yi <- list() 
		for(i in 1:n){
			star.Yi[[i]] <- Yi[[i]] - Zi[[i]] %*% bizero[[i]]
		}

	#one random forests ntree tree
	##############################

	MERF.lDB$star.Yi <- unlist(star.Yi) 
	rm(star.Yi) ;  gc(verbose=FALSE)

	fit.rf.formula <-  as.formula(paste("star.Yi ~ ", paste(xnam, collapse= "+")))
			

	fit.rf <- randomForest(
			formula=fit.rf.formula 
			,data=MERF.lDB	
			,ntree=ntree
			,mtry = mtry 	
			,replace=TRUE	
			,nodesize = nodesize
			,proximity=FALSE	
	)

	#fixed part
		#fixed part predictions as vector
		#MERF.lDB$f.pred  <- predict(fit.rf, newdata=MERF.lDB, type="response")	
		MERF.lDB$f.pred  <- predict(fit.rf, type="response")			#!!!need to use the out-of-bag predictions
		MERF.tDB$f.pred  <- predict(fit.rf, newdata=MERF.tDB, type="response")

		rm(fit.rf);gc(verbose=FALSE)

		#fixed part predictions in matrix format
		fixed.pred <- list()	
		fixed.pred <- split(MERF.lDB, MERF.lDB$cluster.id) 	
		for(i in 1:n)fixed.pred[[i]] <- as.matrix(subset(fixed.pred[[i]] ,select=f.pred), ncol=1)
	
		#mse on fixed part
		if(sim==1){
			f.lmse <- vector(mode="numeric") ;length(f.lmse) <- r 
			f.pmse <- vector(mode="numeric") ;length(f.pmse) <- r 

			f.lmse[r] <- sum((MERF.lDB$fY - MERF.lDB$f.pred)^2)/dim(MERF.lDB)[1]
			f.pmse[r] <- sum((MERF.tDB$fY - MERF.tDB$f.pred)^2)/dim(MERF.tDB)[1]

		}#end if sim==1

	#random	part
		#random effects parameters in list format
		bi <- list(list()) ; length(bi) <- r
		for(i in 1:n)bi[[r]][[i]] <- bizero[[i]] 	
		rm(bizero) ; gc(verbose=FALSE)

		#random part prediction as vector
			a1 <- data.frame(cbind(unique(MERF.lDB$cluster.id), rep(0, n)))
			names(a1) <- c("cluster.id","b1")
			for(j in 1:n){ 
				if(q==1)a1[j,2] <- bi[[r]][[j]]
				else a1[j,2] <- bi[[r]][[j]][1,1]
			}

			l.a1 <- merge(MERF.lDB, a1, by.x="cluster.id", by.y="cluster.id", all.x=TRUE, all.y=TRUE)
			t.a1 <- merge(MERF.tDB, a1, by.x="cluster.id", by.y="cluster.id", all.x=TRUE, all.y=TRUE)
			if(q==1){
				MERF.lDB$r.pred <- l.a1$b1.y
				MERF.tDB$r.pred <- t.a1$b1.y
			}
			rm(a1); gc(verbose = FALSE)

		#mse on random part
		if(sim==1){
			r.lmse <- vector(mode="numeric") ;length(r.lmse) <- r 
			r.pmse <- vector(mode="numeric") ;length(r.pmse) <- r
 
			if(q==1){
				r.lmse[r] <- sum((MERF.lDB$b1 - MERF.lDB$r.pred)^2)/dim(MERF.lDB)[1]
				r.pmse[r] <- sum((MERF.tDB$b1 - MERF.tDB$r.pred)^2)/dim(MERF.tDB)[1]
			}
		}#end if sim==1

	#two parts
		lmse <- vector(mode="numeric") ;length(lmse) <- r 
		pmse <- vector(mode="numeric") ;length(pmse) <- r 

		lmse[r] <- sum((MERF.lDB$Y - MERF.lDB$f.pred - MERF.lDB$r.pred)^2)/dim(MERF.lDB)[1]
		pmse[r] <- sum((MERF.tDB$Y - MERF.tDB$f.pred - MERF.tDB$r.pred)^2)/dim(MERF.tDB)[1]


	#level-1 variance component
		#residuals
		epsili <- list()
		for(i in 1:n)
			epsili[[i]] <- Yi[[i]] - fixed.pred[[i]] - Zi[[i]] %*% bi[[r]][[i]]

		sigma.sq <- vector(mode="numeric") ;length(sigma.sq) <- r
		sigma.sq[r] <- sigmasqzero	#!!!sigmasqzero <- 1
		rm(sigmasqzero) ; gc(verbose=FALSE)
		#message("sigmasq of current micro iter", sigma.sq[r] )

	#level-2 variance component
		D <- list() ;length(D) <- r
		D[[r]] <- Dzero		#!!!Dzero <- diag(x=0.01, nrow=q, ncol = q)
		rm(Dzero) ; gc(verbose=FALSE)
		#message("D of current micro iter: ", D[[r]] )

	#level-1 and level-2 variance components (or typical or total variance)
		Vi <- list() 
		inv.Vi <- list(list()) ; length(inv.Vi) <- r

		for(i in 1:n){
			Vi[[i]] <- Zi[[i]] %*% D[[r]] %*% t(Zi[[i]]) + sigma.sq[r]*diag(x = 1, nrow=ni[i], ncol = ni[i])
			if(q==1)
				inv.Vi[[r]][[i]] <- 
				(1/sigma.sq[r]) * (diag(rep(1,ni[i]))-((as.numeric(D[[r]])/sigma.sq[r])/(1+ni[i]*(as.numeric(D[[r]])/sigma.sq[r])))*matrix(rep(1,(ni[i])^2), ncol=ni[i], nrow=ni[i]) )
			else inv.Vi[[r]][[i]] <- solve(Vi[[i]])
		}

		Vi <- list(NULL) 
		#inv.Vi[[r-1]] <- list(NULL) #not to run at step 0

	#the generalized log-likelihood (GLL) 
		GLL <- vector(mode="numeric") ; length(GLL) <- r
		term <- vector(mode="numeric",length=n)
		for(i in 1:n)
			term[i]<-t(epsili[[i]]) %*% solve(sigma.sq[r]*diag(x=1,nrow=ni[i],ncol=ni[i])) %*% epsili[[i]]
				+ t(bi[[r]][[i]]) %*% solve(D[[r]]) %*% bi[[r]][[i]]
				+ log(abs(D[[r]]))
				+ log(abs(sigma.sq[r]*diag(x=1, nrow=ni[i], ncol = ni[i])))
		GLL[r] <- sum(term)
		rm(term)
		gc(verbose=FALSE)

	#convergence criterion
		Jump <- rep(NA,r) 	#at this first iteration Jump = NA


	#########################################################
	####	STEP 1	#######################################         
	#########################################################

	#update iteration number r
		r <- r+1
		if (verbose) 	
			message("MERF iter ", r)

	#update the length of the different lists

		length(sigma.sq) <- r
		length(D) <- r
		length(inv.Vi) <- r
		length(bi) <- r
		length(GLL) <- r

		if(sim==1){
			length(f.lmse) <- r
			length(f.pmse) <- r
			length(r.lmse) <- r
			length(r.pmse) <- r
		}

		length(lmse) <- r
		length(pmse) <- r

		length(Jump) <- r

	#update the transformed outcome, star.Yi
		star.Yi <- list() 
		for(i in 1:n){
			star.Yi[[i]] <- Yi[[i]] - Zi[[i]] %*% bi[[r-1]][[i]]	
		}	


	#one random forests ntree tree
	##############################

	MERF.lDB$star.Yi <- unlist(star.Yi) 
	rm(star.Yi) ;  gc(verbose=FALSE)
		
	
	fit.rf <- randomForest(
			formula=fit.rf.formula 
			,data=MERF.lDB	
			,ntree=ntree
			,mtry = mtry 	
			,replace=TRUE
			,nodesize = nodesize
			,proximity=FALSE	
	)

	#fixed part
		#fixed part predictions as vector
			#MERF.lDB$f.pred  <- predict(fit.rf, newdata=MERF.lDB, type="response")
			MERF.lDB$f.pred  <- predict(fit.rf, type="response")

			MERF.tDB$f.pred  <- predict(fit.rf, newdata=MERF.tDB, type="response")

		rm(fit.rf);gc(verbose=FALSE)	

		#fixed part predictions in matrix format
		fixed.pred <- list()	
		fixed.pred <- split(MERF.lDB, MERF.lDB$cluster.id) 	
		for(i in 1:n)fixed.pred[[i]] <- as.matrix(subset(fixed.pred[[i]] ,select=f.pred), ncol=1)
	
		#mse on fixed part
		if(sim==1){
			f.lmse[r] <- sum((MERF.lDB$fY - MERF.lDB$f.pred)^2)/dim(MERF.lDB)[1]
			f.pmse[r] <- sum((MERF.tDB$fY - MERF.tDB$f.pred)^2)/dim(MERF.tDB)[1]
		}

	#random	part
		#random effects parameters in list format
		for(i in 1:n)
			bi[[r]][[i]] <- D[[r-1]]%*%t(Zi[[i]]) %*% inv.Vi[[r-1]][[i]] %*% (Yi[[i]] - fixed.pred[[i]])

		bi[r-1] <- list(NULL)		#not to run at step 0 


		#random part prediction as vector
		a1 <- data.frame(cbind(unique(MERF.lDB$cluster.id), rep(0, n)))
		names(a1) <- c("cluster.id","b1")
		for(j in 1:n){ 
			if(q==1)a1[j,2] <- bi[[r]][[j]]
			else a1[j,2] <- bi[[r]][[j]][1,1]
		}

		l.a1 <- merge(MERF.lDB, a1, by.x="cluster.id", by.y="cluster.id", all.x=TRUE, all.y=TRUE)
		t.a1 <- merge(MERF.tDB, a1, by.x="cluster.id", by.y="cluster.id", all.x=TRUE, all.y=TRUE)
		if(q==1){
			MERF.lDB$r.pred <- l.a1$b1.y
			MERF.tDB$r.pred <- t.a1$b1.y
		}
		rm(a1); gc(verbose = FALSE)

		#mse on random part
		if(sim==1){
			if(q==1){
				r.lmse[r] <- sum((MERF.lDB$b1 - MERF.lDB$r.pred)^2)/dim(MERF.lDB)[1]
				r.pmse[r] <- sum((MERF.tDB$b1 - MERF.tDB$r.pred)^2)/dim(MERF.tDB)[1]
			}
		}

	#two parts
		lmse[r] <- sum((MERF.lDB$Y - MERF.lDB$f.pred - MERF.lDB$r.pred)^2)/dim(MERF.lDB)[1]
		pmse[r] <- sum((MERF.tDB$Y - MERF.tDB$f.pred - MERF.tDB$r.pred)^2)/dim(MERF.tDB)[1]



	#########################################################
	####	STEP 2	#######################################         
	#########################################################

	#level-1 variance component
		#residuals
		epsili <- list()
		for(i in 1:n)
			epsili[[i]] <- Yi[[i]] - fixed.pred[[i]] - Zi[[i]] %*% bi[[r]][[i]]


		term <- vector(mode="numeric",length=n)
		for(i in 1:n)
			term[i] <- crossprod(epsili[[i]]) + 
           			sigma.sq[r-1] * (ni[i] - sigma.sq[r-1]* sum(diag(inv.Vi[[r-1]][[i]])))
		sigma.sq[r] <- (1/N)*(sum(term))
		rm(term) ;gc(verbose=FALSE)
		#message("sigmasq of current micro iter", sigma.sq[r] )

	#level-2 variance component
		term <- list()
		term[[1]] <- tcrossprod(bi[[r]][[1]]) + 
                           (	D[[r-1]] - 
                            	D[[r-1]] %*% t(Zi[[1]])%*% inv.Vi[[r-1]][[1]] %*% Zi[[1]] %*% D[[r-1]]
                            )
		for(i in 2:n) 
			term[[i]] <- term[[i-1]]+ tcrossprod(bi[[r]][[i]]) + 
                        (	D[[r-1]] - 
                            	D[[r-1]] %*% t(Zi[[i]]) %*% inv.Vi[[r-1]][[i]]%*% Zi[[i]]%*% D[[r-1]]
                        )
		term <- term[[n]]
		D[[r]] <- (1/n)*term
		rm(term) ;gc(verbose=FALSE)	 
		#message("D of current micro iter: ", D[[r]] )

	#level-1 and level-2 variance components (or typical or total variance)
		inv.Vi[[r]] <-list()
		for(i in 1:n){
			Vi[[i]] <- Zi[[i]] %*% D[[r]] %*% t(Zi[[i]])+sigma.sq[r]*diag(x = 1, nrow=ni[i], ncol = ni[i])
			if(q==1)
				inv.Vi[[r]][[i]] <- 
				(1/sigma.sq[r]) * (diag(rep(1,ni[i]))-((as.numeric(D[[r]])/sigma.sq[r])/(1+ni[i]*(as.numeric(D[[r]])/sigma.sq[r])))*matrix(rep(1,(ni[i])^2), ncol=ni[i], nrow=ni[i]) )
			else inv.Vi[[r]][[i]] <- solve(Vi[[i]])
		}
		Vi <- list(NULL) 
		inv.Vi[[r-1]] <- list(NULL) 	#not to run at step 0


	#the generalized log-likelihood (GLL) 
		term <- vector(mode="numeric",length=n)
		for(i in 1:n)
			term[i]<-t(epsili[[i]]) %*% solve(sigma.sq[r]*diag(x=1,nrow=ni[i],ncol=ni[i])) %*% epsili[[i]]
				+ t(bi[[r]][[i]]) %*% solve(D[[r]]) %*% bi[[r]][[i]]
				+ log(abs(D[[r]]))
				+ log(abs(sigma.sq[r]*diag(x=1, nrow=ni[i], ncol = ni[i])))
		GLL[r] <- sum(term)
		rm(term)
		gc(verbose=FALSE)

	#update the value of the Jump in GLL
		Jump[r] <- abs( (GLL[r]- GLL[r-1])/GLL[r] )

	#########################################################
	####	STEP 3	#######################################         
	#########################################################

#	while( r < (2+niter) ){
#		if(Jump[r] < smallest.Jump.allowed | Jump[r] == smallest.Jump.allowed) {
#			convergence <- TRUE
#			message("convergence is reached at iter: ", r)
#		} 
#
#		if(Jump[r] > smallest.Jump.allowed){#repeat step 1 and 2


	#iterer pour un nb fixe niter
	#############################
	for(I in 1:niter){#repeat step 1 and 2

		#########################################################
		####	STEP 1	#######################################         
		#########################################################

	#update iteration number r
		r <- r+1
		if (verbose) 	
			message("MERF iter ", r)

	#update the length of the different lists

		length(sigma.sq) <- r
		length(D) <- r
		length(inv.Vi) <- r
		length(bi) <- r
		length(GLL) <- r

		if(sim==1){
			length(f.lmse) <- r
			length(f.pmse) <- r
			length(r.lmse) <- r
			length(r.pmse) <- r
		}

		length(lmse) <- r
		length(pmse) <- r

		length(Jump) <- r

	#update the transformed outcome, star.Yi
		star.Yi <- list() 
		for(i in 1:n){
			star.Yi[[i]] <- Yi[[i]] - Zi[[i]] %*% bi[[r-1]][[i]]	
		}
	
	#one random forests ntree tree
	##############################

	MERF.lDB$star.Yi <- unlist(star.Yi) 
	rm(star.Yi) ;  gc(verbose=FALSE)
	
	fit.rf <- randomForest(
			formula=fit.rf.formula 
			,data=MERF.lDB	
			,ntree=ntree
			,mtry = mtry 	
			,replace=TRUE
			,nodesize = nodesize
			,proximity=FALSE	
	)

	#fixed part
		#fixed part predictions as vector
		#MERF.lDB$f.pred  <- predict(fit.rf, newdata=MERF.lDB, type="response")
		MERF.lDB$f.pred  <- predict(fit.rf, type="response")

		MERF.tDB$f.pred  <- predict(fit.rf, newdata=MERF.tDB, type="response")
			
		rm(fit.rf);gc(verbose=FALSE)

		#fixed part predictions in matrix format
		fixed.pred <- list()	
		fixed.pred <- split(MERF.lDB, MERF.lDB$cluster.id) 	
		for(i in 1:n)fixed.pred[[i]] <- as.matrix(subset(fixed.pred[[i]] ,select=f.pred), ncol=1)
	
		#mse on fixed part
		if(sim==1){
			f.lmse[r] <- sum((MERF.lDB$fY - MERF.lDB$f.pred)^2)/dim(MERF.lDB)[1]
			f.pmse[r] <- sum((MERF.tDB$fY - MERF.tDB$f.pred)^2)/dim(MERF.tDB)[1]
		}

	#random	part
		#random effects parameters in list format
		for(i in 1:n)
			bi[[r]][[i]] <- D[[r-1]]%*%t(Zi[[i]]) %*% inv.Vi[[r-1]][[i]] %*% (Yi[[i]] - fixed.pred[[i]])
		bi[r-1] <- list(NULL)		#not to run at step 0 


		#random part prediction as vector
		a1 <- data.frame(cbind(unique(MERF.lDB$cluster.id), rep(0, n)))
		names(a1) <- c("cluster.id","b1")
		for(j in 1:n){ 
			if(q==1)a1[j,2] <- bi[[r]][[j]]
			else a1[j,2] <- bi[[r]][[j]][1,1]
		}

		l.a1 <- merge(MERF.lDB, a1, by.x="cluster.id", by.y="cluster.id", all.x=TRUE, all.y=TRUE)
		t.a1 <- merge(MERF.tDB, a1, by.x="cluster.id", by.y="cluster.id", all.x=TRUE, all.y=TRUE)
		if(q==1){
			MERF.lDB$r.pred <- l.a1$b1.y
			MERF.tDB$r.pred <- t.a1$b1.y
		}
		rm(a1); gc(verbose = FALSE)

		#mse on random part
		if(sim==1){
			if(q==1){
				r.lmse[r] <- sum((MERF.lDB$b1 - MERF.lDB$r.pred)^2)/dim(MERF.lDB)[1]
				r.pmse[r] <- sum((MERF.tDB$b1 - MERF.tDB$r.pred)^2)/dim(MERF.tDB)[1]
			}
		}

	#two parts
		lmse[r] <- sum((MERF.lDB$Y - MERF.lDB$f.pred - MERF.lDB$r.pred)^2)/dim(MERF.lDB)[1]
		pmse[r] <- sum((MERF.tDB$Y - MERF.tDB$f.pred - MERF.tDB$r.pred)^2)/dim(MERF.tDB)[1]



		#########################################################
		####	STEP 2	#######################################         
		#########################################################

	#level-1 variance component
		#residuals
		epsili <- list()
		for(i in 1:n)
			epsili[[i]] <- Yi[[i]] - fixed.pred[[i]] - Zi[[i]] %*% bi[[r]][[i]]


		term <- vector(mode="numeric",length=n)
		for(i in 1:n)
			term[i] <- crossprod(epsili[[i]]) + 
           			sigma.sq[r-1] * (ni[i] - sigma.sq[r-1]* sum(diag(inv.Vi[[r-1]][[i]])))
		sigma.sq[r] <- (1/N)*(sum(term))
		rm(term) ;gc(verbose=FALSE)
		#message("sigmasq of current micro iter", sigma.sq[r] )

	#level-2 variance component
				term <- list()
		term[[1]] <- tcrossprod(bi[[r]][[1]]) + 
                           (	D[[r-1]] - 
                            	D[[r-1]] %*% t(Zi[[1]])%*% inv.Vi[[r-1]][[1]] %*% Zi[[1]] %*% D[[r-1]]
                            )
		for(i in 2:n) 
			term[[i]] <- term[[i-1]]+ tcrossprod(bi[[r]][[i]]) + 
                        (	D[[r-1]] - 
                            	D[[r-1]] %*% t(Zi[[i]]) %*% inv.Vi[[r-1]][[i]]%*% Zi[[i]]%*% D[[r-1]]
                        )
		term <- term[[n]]
		D[[r]] <- (1/n)*term
		rm(term) ;gc(verbose=FALSE)	 
		#message("D of current micro iter: ", D[[r]] )

	#level-1 and level-2 variance components (or typical or total variance)
		inv.Vi[[r]] <-list()
		for(i in 1:n){
			Vi[[i]] <- Zi[[i]] %*% D[[r]] %*% t(Zi[[i]])+sigma.sq[r]*diag(x = 1, nrow=ni[i], ncol = ni[i])
			if(q==1)
				inv.Vi[[r]][[i]] <- 
				(1/sigma.sq[r]) * (diag(rep(1,ni[i]))-((as.numeric(D[[r]])/sigma.sq[r])/(1+ni[i]*(as.numeric(D[[r]])/sigma.sq[r])))*matrix(rep(1,(ni[i])^2), ncol=ni[i], nrow=ni[i]) )
			else inv.Vi[[r]][[i]] <- solve(Vi[[i]])
		}
		Vi <- list(NULL) 
		inv.Vi[[r-1]] <- list(NULL) 	#not to run at step 0


	#the generalized log-likelihood (GLL) 
		term <- vector(mode="numeric",length=n)
		for(i in 1:n)
			term[i]<-t(epsili[[i]]) %*% solve(sigma.sq[r]*diag(x=1,nrow=ni[i],ncol=ni[i])) %*% epsili[[i]]
				+ t(bi[[r]][[i]]) %*% solve(D[[r]]) %*% bi[[r]][[i]]
				+ log(abs(D[[r]]))
				+ log(abs(sigma.sq[r]*diag(x=1, nrow=ni[i], ncol = ni[i])))
		GLL[r] <- sum(term)
		rm(term)
		gc(verbose=FALSE)

	#update the value of the Jump in GLL
		Jump[r] <- abs( (GLL[r] - GLL[r-1])/GLL[r] )


	}#end for I in 1: niter and STOP repeating step 1 and 2
	#######################################################

#		}#end if and STOP repeating step 1 and 2
#		else break

	#################################
#	}#	END OF STEP 3 	#  
	#################################

	#########################
	# Final model selection #
	#########################
		#smoothed GLL on a w iterations window basis (length(sGLL) = r-1)
			sGLL <- rollmean(GLL[-1], k=w, na.pad = TRUE, align = c("right"))	#Notice that sGLL = NA at the first w-1 iterations among the r-1 iterations

		#Jump on the smoothed GLL (length(sJump) = r-1)
			sJump <- rep(NA,r-1)
			for(i in 2:(r-1)) sJump[i] <- abs( (sGLL[i] - sGLL[i-1]) / sGLL[i])		#Notice that sJump = NA at the first w iteration


	#Plots over MERF iteration
	##########################
if(sim == 1){
	par(mfrow=c(3,4),cex=0.6)

	iter <- 1:r
	
	#GLL plot
	plot(GLL[-1]~iter[-1], xlab="iter", ylab="GLL")
	title("MERF", cex.main=1.5)
	mtext("GLL" , side = 3,line = 0 ,cex=0.6)

	#smoothed GLL plot
	plot(sGLL~iter[-1], xlab="iter", ylab="sGLL")
	mtext("Smoothed GLL" , side = 3,line = 0 ,cex=0.6)

	#Jump plot
	plot(Jump[-1][-1] ~ iter[-1][-1], xlab="iter", ylab="Jump")
	mtext("GLL Jumps" , side = 3,line = 0 ,cex=0.6)

	#Jump on smoothed GLL plot
	plot(sJump[-1] ~ iter[-1][-1], xlab="iter", ylab="sJump")
	mtext("sGLL Jump", side = 3,line = 1 ,cex=0.6)
	
	#f.lmse plot
	plot(f.lmse~iter, xlab="iter", ylab="f.lmse")
	mtext("f.LMSE" , side = 3,line = 0 ,cex=0.6)

	#f.pmse plot
	plot(f.pmse~iter, xlab="iter", ylab="f.pmse")
	mtext("f.PMSE" , side = 3,line = 0 ,cex=0.6)

	#r.lmse plot
	plot(r.lmse~iter, xlab="iter", ylab="r.lmse")
	mtext("r.LMSE" , side = 3,line = 0 ,cex=0.6)
	
	#r.pmse plot
	plot(r.pmse~iter, xlab="iter", ylab="r.pmse")
	mtext("r.PMSE" , side = 3,line = 0 ,cex=0.6)

	#lmse plot
	plot(lmse~iter, xlab="iter", ylab="lmse")
	mtext("LMSE" , side = 3,line = 0 ,cex=0.6)

	#pmse plot
	plot(pmse~iter, xlab="iter", ylab="pmse")
	mtext(paste("PMSE at iter 1: ",  round(pmse[1],digits=3)), side = 3,line = 1 ,cex=0.5)
	mtext(paste("PMSE at last iter: ",  round(pmse[r],digits=3)), side = 3,line = 0 ,cex=0.5)

	#sigma.sq plot
	plot(sigma.sq~iter, xlab="iter", ylab="sigma.sq")
	mtext("sigma.sq" , side = 3,line = 0 ,cex=0.6)

	#d11 plot
	d11 <- rep(0, r)
	for(i in 1:r)d11[i] <- D[[i]][1,1]
	plot(d11 ~ iter, xlab="iter", ylab="d11")
	mtext("d11" , side = 3,line = 0 ,cex=0.6)

	rm(iter,d11); gc(verbose=FALSE)

}#end if sim==1

	#output to be returned
	######################
	if(q==1){
		output <- list(
				GLL, sGLL
				,lmse, pmse 
				,r
		)		
		names(output) <- c(
				"GLL", "sGLL"
				,"lmse", "pmse"
				,"r"
		)
	}

	#clean memory
	#############
	rm(
		bi,D,epsili,fixed.pred,i,inv.Vi,j,MERF.lDB,MERF.tDB,n,N,ni,niter
		,p,q,r,sigma.sq,Vi,Yi,Zi
		,Jump ,GLL ,smallest.Jump.allowed
		,fit.rf.formula 
		,l.a1 ,lmse ,mtry ,nodesize ,ntree ,pmse 
		,sGLL ,sim ,sJump ,t.a1 ,verbose ,w ,xnam ,I	
	)
	gc(verbose=FALSE)

	if(sim==1)rm(f.lmse ,f.pmse,r.lmse  ,r.pmse)
	gc(verbose=FALSE)

	if(q==2)rm(b2);gc(verbose=FALSE)

	#message("ls()",ls())


	#return
	#######
	output

	}#end of MERF function
	############################################################################################################
	############################################################################################################
	############################################################################################################


### end of the script	###

sink()


